---
title: "`r params$analysis.id`"
author: "`r params$name`"
date: "`r Sys.Date()`"
version: "v1.5.1"
output: 
     html_document:
          toc: true
params:
     name: "Kyle"
     directory: "C:/Users/ks0316/Documents/PQReportCompiler/HOLD 091316"
     stats.filter: "none" #"LIS/Failed" #LIS #Failed #"none"
     assay: "Paraflu"#"AdV/hMPV/RV" #"Flu A/B/RSV"
     worklist.id: "C:/Users/ks0316/Documents/PQReportCompiler/worklist.id.2.csv"
     limits: "C:/Users/ks0316/Documents/PQReportCompiler/assay.limits.csv"
     ignore.flags: TRUE
     analysis.id: "Generic Analysis ID"
     graphing: "no"
---
<style>
body {
    position: absolute;
    left: 10px;}
table {
    text-align: left;
    border-collapse: collapse;
    width: 100%;
}
th, td {
    text-align: left;
    padding: 8px;
}
tr:nth-child(even){background-color: #f2f2f2}
th {
    text-align: left;
    background-color: #00008B;
    color: white;
}
</style>

<!-- #Parameters Entered -->
<!-- ```{r set-options, echo=FALSE, cache=FALSE} -->

<!-- ### At home testing -->
<!-- # params = list( -->
<!-- #                name="Kyle", -->
<!-- #                directory="C:/Users/ks0316/Documents/PQReportCompiler", -->
<!-- #                stats.filter= "none",#"LIS/Failed", #LIS #Failed #LIS/Failed, -->
<!-- #                assay = "Paraflu",#"AdV/hMPV/RV", "Paraflu", -->
<!-- #                worklist.id="C:/Users/ks0316/Documents/PQReportCompiler/worklist.id.2.csv", -->
<!-- #                limits="C:/Users/ks0316/Documents/PQReportCompiler/assay.limits.csv", -->
<!-- #                analysis.id="generic title.html", -->
<!-- #                graphing="instrument") -->

<!-- ``` -->
#Overview {.tabset .tabset-pills}
##Loading in the data
*The script here serves as a log for diagnostic reasons and will show if any of the input files have been altered fatally or if any issues with importing data have been detected.*

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=TRUE, cache=FALSE}
library(dplyr)
library(ggplot2)
library(tidyr)
library(lubridate)
library(stringr)
library(formattable)
library(DT)
library(htmltools)
library(knitr)
source(file="./allFunctions3.R")

get.rdata.name <- function(){
     z <- Sys.time()
     z2 <- unclass(z)
     z3 <- floor(z2)
     final.string <- paste0(params$name, params$analysis.id, "_", Sys.Date(), "_", z3, ".Rdata")
     return(final.string)
}
rdata.filename <- get.rdata.name()
save.image(rdata.filename)

print(params)

wlid <- read.csv(params$worklist.id, stringsAsFactors = FALSE)
print("Loaded Worklist ID.")

if(params$limits != "nonspecified"){
     print("Loading assay.limits file...")
     assay.limits <- read.csv(params$limits, stringsAsFactors = FALSE)
     print("Complete.")
}

setwd(params$directory)
lof <- list.files(pattern="@DI", path=params$directory, full.names = T)

a <- basename(lof)
b <- strsplit(a, split="_")
c <- lapply(b, `[[`, 1)
d <- unlist(c)
filt.v <- !grepl(pattern="@DI", d)
lof <- lof[filt.v] #filtered list of files
rm(a, b, c, d, filt.v)


pq0 <- appender(lof, grabber)
if(all(pq0$list.output$loaded == "LOADED")){
     cat("All PCRExport files have been loaded.")
     pq0 <- pq0$pq.data
} else{
     cat("Some PCRExport files had issues being loaded, see output.")
     pq0 <- pq0$pq.data
     print(pq0$list.output$files[pq0$list.output$loaded != "LOADED"])
}

### Filter all-non related assays
pq0 <- pq0 %>% filter(FusionAssayName == params$assay)

### Clean up and prevent categorization issues
#Round down RFU Range
pq0$RFU.Range <- floor(pq0$RFU.Range)
pq0$ct <- signif(pq0$ct, digits=4)

### Special Escape characters
pq0$Sample.Name <- gsub("`", "battick", pq0$Sample.Name)
pq0$Sample.Name <- gsub("\\\\", "double-slash", pq0$Sample.Name)

######################################################## LIS Component
# parameters
#stats.filter: "none" #LIS #Failed #LIS/Failed

if(params$stats.filter == "LIS" | params$stats.filter == "LIS/Failed"){
     lis <- lis.grabber()
     lis.f <- lis %>% filter(Assay.Name == params$assay) ###### This needs to be worked on
     lis.pcr.join = left_join(pq0, lis.f, by=c("Run.ID", "test.order"="Test.order.."))
     # print("LIS imported and results are filtered!")
     pq0 <- lis.pcr.join %>%
          filter(!(Interpretation.6 %in% c("Invalid", "Error"))) %>%
          filter(!(Interpretation.7 %in% c("Invalid", "Error"))) %>%
          filter(!(Interpretation.8 %in% c("Invalid", "Error"))) %>%
          filter(!(Interpretation.9 %in% c("Invalid", "Error"))) %>%
          filter(!(Interpretation.10 %in% c("Invalid", "Error"))) %>%
          select(-c(Assay.Name, Interpretation.6:Interpretation.10))
     
     filtered.samples.1 <- lis.pcr.join %>%
          filter(Interpretation.6 %in% c("Invalid", "Error") | Interpretation.7 %in% c("Invalid", "Error") |
                      Interpretation.8 %in% c("Invalid", "Error") |Interpretation.9 %in% c("Invalid", "Error") |
                      Interpretation.10 %in% c("Invalid", "Error")) %>%
          select(-c(Assay.Name, Interpretation.6:Interpretation.10))

     if((dim(lis.pcr.join)[1] != dim(pq0)[1]) == FALSE){
          print("Warning: Dimensions of LIS and PCRExport do not match.")
     }
     stats.filter.lv.1 <- TRUE
} else{
     stats.filter.lv.1 <- FALSE

}

#########################################################################
pq0 <- categorizer(pq0, inputfile = wlid)
uncat <- pq0 %>%
     group_by(filename) %>%
     summarise(Uncategorized = sum(is.na(sample.type)))

### Filtering logical vectors
nslv <- wlid %>% filter(logical.vector == "ns") %>% select(type) %>% unique %>% unlist
pslv <- wlid %>% filter(logical.vector == "ps") %>% select(type) %>% unique %>% unlist

pq0[,c("sample.type", "Channel")] <- lapply(pq0[,c("sample.type", "Channel")], as.character)
assay.limits[,c("sample.type", "Channel")] <- lapply(assay.limits[,c("sample.type", "Channel")], as.character)

### PQ ZERO ENDS HERE
pq  <-  left_join(pq0, assay.limits, by=c("sample.type", "Channel"))

pq <- pq %>%
     mutate(pass = ifelse((direction=="min" & RFU.Range > threshold) | (direction=="max" & RFU.Range < threshold), "PASS", "FAIL")) %>%
     mutate(passes=ifelse(pass == "PASS", 1, 0))

### Filtering site #2
#stats.filter: "none" #LIS #Failed #LIS/Failed
if(params$stats.filter == "Failed" | params$stats.filter == "LIS/Failed"){
     any.passes <- any(pq$passes == 0)
     if(any.passes == TRUE){
          filtered.samples.2 <- pq %>% filter(passes == 0) %>% select(Sample.Name:Flag, filename)
          
          ################# Development
          filter.2 <- filtered.samples.2 %>% select(Sample.Name:Flag, filename)
          filter.2 <- left_join(filter.2, pq)
          
          # selectedRows <- (filter.2$filename %in% pq$filename &
          #                       filter.2$Sample.Name %in% pq$Sample.Name &
          #                       filter.2$test.order %in% pq$test.order)
          # selectedRows <- (pq$Sample.Name %in% filter.2$Sample.Name &
          #                       pq$test.order %in% filter.2$test.order)
          
          pq <- anti_join(pq, filter.2)
          print("LIS and Failed samples have been filtered")
          stats.filter.lv.2 <- TRUE
     } else{
          print("No failed samples.")
     }
} else{
     stats.filter.lv.2 <- FALSE
}
save.image(rdata.filename)
```

## PQ Result
*PQ Result shows a succinct summary of the each PCRExport file including its:*
<ul>
<li>Assay Name</li>
<li>Assay Version</li>
<li>Panther SN - which can be traced back from the @DI file if the instrument has been set up properly</li>
<li>Flags - A total number of what flags have been reported in each run</li>
<li>Result - This will depend heavily on what the user specifies for assay limits and by default if any other flag other than an "IUO" will result in a "Pending" result for root-cause analysis.</li>
<li>Uncategorized Samples - Will report back the number of samples that have not been able to group using the Worklist ID that must be loaded with each analysis.</li>
</ul>
``` {R, result='asis', echo=FALSE, cache=FALSE, warning=FALSE, message=FALSE}
summary.pq  <- pq %>%
     group_by(filename, FusionAssayName, FusionAssayVersion, pantherSN, Channel, sample.type) %>%
     summarise(Mean.RFU.Range = mean(RFU.Range, na.rm=T), Sd.RFU.Range = sd(RFU.Range, na.rm=T),
               Max.RFU.Range = max(RFU.Range, na.rm=T), Min.RFU.Range=min(RFU.Range, na.rm=T),
               N = n(), Positive = sum(passes),
               Mean.Ct = mean(ct, na.rm=T), Sd.Ct = sd(ct, na.rm=T),
               Max.Ct = max(ct, na.rm=T), Min.Ct = min(ct, na.rm=T)) %>%
     mutate(CV = Sd.Ct/Mean.Ct*100, Pass.Fail = ifelse(N == Positive, 1, ifelse(Channel == "RED647" & N-Positive <= 2, 1, 0)))

#### Summary1 - RFU Range/Ct
summary1.pq <- pq %>%
     group_by(Software.Revision, Channel, sample.type) %>%
     summarise(Mean.RFU.Range = mean(RFU.Range, na.rm=T), Sd.RFU.Range = sd(RFU.Range, na.rm=T),
               Max.RFU.Range = max(RFU.Range, na.rm=T), Min.RFU.Range=min(RFU.Range, na.rm=T),
               N = n(), Positive = sum(passes),
               Mean.Ct = mean(ct, na.rm=T), Sd.Ct = sd(ct, na.rm=T),
               Max.Ct = max(ct, na.rm=T), Min.Ct = min(ct, na.rm=T)) %>%
     mutate(CV = Sd.Ct/Mean.Ct*100,
            Pass.Fail = ifelse(N == Positive, "PASS",
                               ifelse(Channel == "RED647" & N-Positive <= 2, "PASS", "FAIL")),
            Passes = paste(Positive, N, sep="/")) %>%
     ungroup() %>%
     select(Software.Revision, Channel, sample.type, Mean.RFU.Range, Sd.RFU.Range, Max.RFU.Range, Min.RFU.Range,
            Mean.Ct, Sd.Ct, Max.Ct, Min.Ct, CV, Passes) %>%
     arrange(sample.type)

summary1.pq$CV  <- percent(summary1.pq$CV)/100
summary1.pq$Mean.RFU.Range <- floor(summary1.pq$Mean.RFU.Range)
summary1.pq$Sd.RFU.Range <- floor(summary1.pq$Sd.RFU.Range)
summary1.pq[,c("Mean.Ct", "Sd.Ct")] <- lapply(summary1.pq[,c("Mean.Ct", "Sd.Ct")], signif, digits=4)

#### Summary2 - EB/Tslope
summary2.pq <- pq %>%
     group_by(Software.Revision, Channel, sample.type) %>%
     summarise(Mean.EstimatedBaseline = mean(EstimatedBaseline, na.rm=T), Sd.EstimatedBaseline = sd(EstimatedBaseline, na.rm=T),
               Max.EstimatedBaseline = max(EstimatedBaseline, na.rm=T), Min.EstimatedBaseline=min(EstimatedBaseline, na.rm=T),
               N = n(),
               Mean.tslope = mean(tslope, na.rm=T), Sd.tslope = sd(tslope, na.rm=T),
               Max.tslope = max(tslope, na.rm=T), Min.tslope = min(tslope, na.rm=T)) %>%
     mutate(CV = Sd.tslope/Mean.tslope*100) %>%
     ungroup() %>%
     select(Software.Revision, Channel, sample.type, Mean.EstimatedBaseline, Sd.EstimatedBaseline, Max.EstimatedBaseline, Min.EstimatedBaseline,
            Mean.tslope, Sd.tslope, Max.tslope, Min.tslope, CV) %>%
     arrange(sample.type)

summary2.pq$CV  <- percent(summary2.pq$CV)/100
summary2.pq[,c("Mean.tslope", "Sd.tslope", "Max.EstimatedBaseline", "Min.EstimatedBaseline")] <- lapply(summary2.pq[,c("Mean.tslope", "Sd.tslope", "Max.tslope", "Min.tslope")], signif, digits=4)
summary2.pq[,c("Mean.EstimatedBaseline", "Sd.EstimatedBaseline", "Max.EstimatedBaseline", "Min.EstimatedBaseline")] <- lapply(summary2.pq[,c("Mean.EstimatedBaseline", "Sd.EstimatedBaseline", "Max.EstimatedBaseline", "Min.EstimatedBaseline")], floor)

condensed.summary <-
     summary.pq %>%
     ungroup() %>%
     group_by(filename, FusionAssayName, FusionAssayVersion, pantherSN) %>%
     summarise(PQ.PF=sum(Pass.Fail), count = n()) %>%
     mutate(Chemistry.Pass =ifelse(PQ.PF == count, 1, 0))

########################## Bold attempt at error handling... something is going down in flaggregator.
# flaggregator(df = pq, assay=params$assay) %>% utils::View()

attempt <- try(flaggregator(df = pq, assay=params$assay))

if(any(class(attempt) == "try-error") == FALSE){
     c.summary2 <- left_join(condensed.summary, flaggregator(df = pq, assay=params$assay), by="filename")
     c.summary2 <- other_flags(c.summary2)
     
     if(params$assay=="Paraflu" & params$ignore.flags==FALSE){
          c.summary3 <- c.summary2 %>%
               group_by(filename, FusionAssayName, FusionAssayVersion, pantherSN, Flags) %>%
               summarise(Result = ifelse(Chemistry.Pass == 1 & VVFS <= 6 & other.flags == TRUE, "PASS",
                                         ifelse(other.flags == FALSE | is.na(Chemistry.Pass), "PENDING", "FAIL")))
     } else {
          if(params$ignore.flags == TRUE){
               c.summary3 <- c.summary2 %>%
                    group_by(filename, FusionAssayName, FusionAssayVersion, pantherSN, Flags) %>%
                    summarise(Result = ifelse(Chemistry.Pass == 1 & !is.na(Chemistry.Pass), "PASS",
                                              ifelse(is.na(Chemistry.Pass), "PENDING", "FAIL")))
          } else{
               message("Under development...")
          }
     }
     
     c.summary3$Uncategorized.Samples <- uncat$Uncategorized
     
     datatable(c.summary3, list(Result = formatter("span",
     style = x ~ ifelse(x == "PASS", style(color="green"),
     ifelse(x =="PENDING", style(color="orange"), style(color="red"))))))
} else{
     print("Issue with flaggregator.")
}
save.image(rdata.filename)
```

## Summary statistics of PQ
*In this table the script will compile summary statistics for the entire report by Sample Type and Channel.*

*Each column represents a different Channel for each specified Sample Type the row names are the relevant summary statistics for that Channel and Sample Type*

``` {R, results='asis', echo=FALSE, cache=FALSE}
panel.rows <- summary1.pq %>% filter(grepl("Panel", sample.type)) %>% nrow

cat("<h3>Positive and Negative Samples - RFU Range and Ct Summary</h3>")
cat("<ul>")
cat("<li><b>CV</b> - The Coefficient of Variance for the Ct is simply calculated by the Standard Deviation divided by the mean and is represented as a percentage.</li>")
cat("<li>The number of <b>Passes</b> are counted by the number of samples passing the the assay limits thresholds shown in the table below.</li>")
cat("</ul>")

s1.pq.t <- summary1.pq %>%
     filter(sample.type %in% pslv) %>%
     select(sample.type, Channel, everything()) %>%
     rename(Sample.Type=sample.type) %>%
     t()
s1.pq.t[is.na(s1.pq.t)] = "-"
print(kable(s1.pq.t, format="html"))

s2.pq.t <- summary1.pq %>%
     filter(sample.type %in% nslv) %>%
     select(sample.type, Channel, everything()) %>%
     rename(Sample.Type=sample.type) %>%
     t()
s2.pq.t[is.na(s2.pq.t)] = "-"
print(kable(s2.pq.t, format="html"))
cat("<h3>Positive and Negative Samples - Estimated Baseline and Tslope Summary</h3>")
cat("<ul>")
cat("<li><b>CV</b> - The Coefficient of Variance for the TSlope is simply calculated by the Standard Deviation divided by the mean and is represented as a percentage.</li>")
cat("</ul>")

# ``` {R, result='asis', echo=FALSE, cache=FALSE}

s3.pq.t <- summary2.pq %>%
     filter(sample.type %in% pslv) %>%
     select(sample.type, Channel, everything()) %>%
     rename(Sample.Type=sample.type) %>%
     t()
s3.pq.t[is.na(s3.pq.t)] = "-"

print(kable(s3.pq.t, format="html"))

s4.pq.t <- summary2.pq %>%
     filter(sample.type %in% nslv) %>%
     select(sample.type, Channel, everything()) %>%
     rename(Sample.Type=sample.type) %>%
     t()
s4.pq.t[is.na(s4.pq.t)] = "-"
# print(kable(as.data.frame(s4.pq.t), format="html"))
print(kable(s4.pq.t, format="html"))
# print(formattable(s4.pq.t, format="html"))
```



``` {R, results='asis', echo=FALSE}
temp <- pq %>%
     group_by(filename, Software.Revision, Channel, sample.type) %>%
     summarise(Mean.RFU.Range = mean(RFU.Range, na.rm=T), Sd.RFU.Range = sd(RFU.Range, na.rm=T),
               Max.RFU.Range = max(RFU.Range, na.rm=T), Min.RFU.Range=min(RFU.Range, na.rm=T),
               N = n(), Positive = sum(passes),
               Mean.Ct = mean(ct, na.rm=T), Sd.Ct = sd(ct, na.rm=T),
               Max.Ct = max(ct, na.rm=T), Min.Ct = min(ct, na.rm=T)) %>%
     mutate(CV = Sd.Ct/Mean.Ct*100,
            Pass.Fail = ifelse(N == Positive, "PASS",
                               ifelse(Channel == "RED647" & N-Positive <= 2, "PASS", "FAIL")),
            Passes = paste(Positive, N, sep="/")) %>%
     ungroup() %>%
     select(filename, Software.Revision, Channel, sample.type, Mean.RFU.Range, Sd.RFU.Range, Max.RFU.Range, Min.RFU.Range,
            Mean.Ct, Sd.Ct, Max.Ct, Min.Ct, CV, Passes)

temp$CV  <- percent(temp$CV)/100
temp$Mean.RFU.Range <- floor(temp$Mean.RFU.Range)
temp$Sd.RFU.Range <- floor(temp$Sd.RFU.Range)
temp[,c("Mean.Ct", "Sd.Ct")] <- lapply(temp[,c("Mean.Ct", "Sd.Ct")], signif, digits=4)



temp.list <- split(temp, temp$filename)
```

## File-by-file Summaries
``` {R, results='asis', echo=FALSE}
temp2 <- pq %>%
     group_by(filename, Software.Revision, Channel, sample.type) %>%
     summarise(Mean.EstimatedBaseline = mean(EstimatedBaseline, na.rm=T),
               Sd.EstimatedBaseline = sd(EstimatedBaseline, na.rm=T),
               Max.EstimatedBaseline = max(EstimatedBaseline, na.rm=T),
               Min.EstimatedBaseline=min(EstimatedBaseline, na.rm=T),
               N = n(),
               Mean.tslope = mean(tslope, na.rm=T), Sd.tslope = sd(tslope, na.rm=T),
               Max.tslope = max(tslope, na.rm=T), Min.tslope = min(tslope, na.rm=T)) %>%
     mutate(CV = Sd.tslope/Mean.tslope*100) %>%
     ungroup() %>%
     select(filename, Software.Revision, Channel, sample.type, Mean.EstimatedBaseline, Sd.EstimatedBaseline, Max.EstimatedBaseline, Min.EstimatedBaseline, N,
            Mean.tslope, Sd.tslope, Max.tslope, Min.tslope, CV)

temp2$CV  <- percent(temp2$CV)/100
temp2[,c("Mean.EstimatedBaseline", "Sd.EstimatedBaseline", "Max.EstimatedBaseline", "Min.EstimatedBaseline")] <- lapply(temp2[,c("Mean.EstimatedBaseline", "Sd.EstimatedBaseline", "Max.EstimatedBaseline", "Min.EstimatedBaseline")], floor)




temp2[,c("Mean.tslope", "Sd.tslope", "Max.tslope", "Min.tslope")] <- lapply(temp2[,c("Mean.tslope", "Sd.tslope", "Max.tslope", "Min.tslope")], signif, digits=4)
temp.list2 <- split(temp2, temp2$filename)

cat("<select id=\"dropdown-menu\">")
for (i in 1:length(temp.list2)){
     cat(paste0("<option value=\'#mytable2-", i, "\'>", names(temp.list2)[[i]], "</option>"))
     cat("\n")
}
cat("</select>")
cat("<hr>")

for(i in 1:length(temp.list2)){
		pos.test <- temp.list[[i]] %>%
			  select(-filename) %>%
			  filter(sample.type %in% pslv) %>%
			  select(sample.type, Channel, everything()) %>%
			  rename(Sample.Type=sample.type) %>%
			  arrange(Sample.Type) %>%
			  t()
		pos.test[is.na(pos.test)] = "-"

		negative.test <- temp.list[[i]] %>%
			  select(-filename) %>%
			  filter(sample.type %in% nslv) %>%
			  select(sample.type, Channel, everything()) %>%
			  rename(Sample.Type=sample.type) %>%
			  arrange(Sample.Type) %>%
			  t()
		negative.test[is.na(negative.test)] = "-"
		
          pos.test2 <- temp.list2[[i]] %>%
               select(-filename) %>%
               filter(sample.type %in% pslv) %>%
               select(sample.type, Channel, everything()) %>%
               rename(Sample.Type=sample.type) %>%
               arrange(Sample.Type) %>%
               t()
          pos.test2[is.na(pos.test)] = "-"



          negative.test2 <- temp.list2[[i]] %>%
               select(-filename) %>%
               filter(sample.type %in% nslv) %>%
               select(sample.type, Channel, everything()) %>%
               rename(Sample.Type=sample.type) %>%
               arrange(Sample.Type) %>%
               t()
          negative.test2[is.na(negative.test2)] = "-"

          
          cat(paste0("<div", paste0(" id=\"mytable2-", i, "\" style=\"display:none\">")))
          cat("<h3>Positive Sample - RFU Range and Ct Statistics</h3>")
          print(kable(pos.test, format="html"))
          cat("<br>")
          cat("<h3>Positive Sample - Estimated Baseline and Tslope Statistics</h3>")
		print(kable(pos.test2, format="html"))
          cat("<br>")
          cat("<h3>Negative Sample - RFU Range and Ct Statistics</h3>")
		print(kable(negative.test, format="html"))
          cat("<br>")
          cat("<h3>Negative Sample - Estimated Baseline and Tslope Statistics</h3>")
		print(kable(negative.test2, format="html"))

          cat("</div>")

}



```
<a href="#top">Go to top</a>

<script>
     // Where the magic happens
     
     // Get the value of the first table to show it
     var first_table = $("#dropdown-menu").val();
     $(first_table).show();
     
     // Initialize previous
     var previous = first_table;
     
     $("#dropdown-menu").change(function() {
     
       $(previous).hide();
     
       var get_selection = $(this).val();
     
       // Set current to new previous
       previous = get_selection
     
     $(get_selection).show();
      })
      
</script>

#Assay Defined Thresholds
*Pass/Fail Criteria - Below are the assay limits which the user will have the ability to input manually via a submittable file or use the default Paraflu PQ thresholds.*

``` {R, result='asis', echo=FALSE}
assay.limits.t <- assay.limits %>%
     filter(!grepl("Control", sample.type)) %>%
     mutate(Threshold=ifelse(direction=="min", paste0("min. ", threshold), paste0("max. ", threshold))) %>%
     rename(Sample.Type=sample.type) %>%
     select(Sample.Type, Channel, Threshold) %>%
     t()
     
kable(assay.limits.t, output="html")
save.image(rdata.filename)
```

# Positive Samples
*The table has the data from PCRExport aggregated from a "long" to "wide" format and reports back the positivity or negative for a sample based off of the user-defined thresholds. This table will comprise of all the samples categorized as a "ps" (Positive Sample) in the worklist.id and the table has the several built in features:*

**Abbreviations**
<ul>
<li><b>[Channel].ct</b> - Cycle Threshold</li>
<li><b>[Channel].rr</b> - RFU Range</li>
<li><b>[Channel].eb</b> - Estimated Baseline</li>
</ul>

**Features**
<ul>
<li><b>Copy</b> - Will copy the entire table to your clipboard useful for Excel processing.</li>
<li><b>CSV</b> - Will open a prompt for saving the data table as a CSV file.</li>
<li><b>Column visibility</b> - By clicking on this button it will allow the user to see all the surpressed columns: such as Replicates, Estimated Baseline, Ct, Tslope.</li>
<li><b>Search</b> - Will search the entire table for a specified string. It is good for searching for specific filenames.</li>
<li><b>Up/Down Arrows</b> - for ordering a column in increasing decreasing order.</li>
</ul>

``` {R, result='asis', echo=FALSE, cache=FALSE, warning=FALSE, message=FALSE}
pq.s <- pq %>% select(-pass, -threshold, -direction) %>% spreader()

if(params$assay=="Paraflu"){
     temp.table <-
          pq.s %>% ungroup() %>%
          filter(sample.type %in% pslv) %>%
          mutate(FAM.Result = ifelse(FAM.result == 1, "POS", "NEG"),
                 HEX.Result = ifelse(HEX.result == 1, "POS", "NEG"),
                 IC.Result = ifelse(IC.result == 1, "POS", "NEG"),
                 RED647.Result = ifelse(RED647.result == 1, "POS", "NEG"),
                 ROX.Result = ifelse(ROX.result == 1, "POS", "NEG")) %>%
          select(Sample.Name, Flag, FusionTestOrder, test.order, WellID, replicate,
                 FAM.ct:FAM.eb, FAM.Result, HEX.ct:HEX.eb, HEX.Result,
                 IC.ct:IC.eb, IC.Result, RED647.ct:RED647.eb, RED647.Result,
                 ROX.ct:ROX.eb, ROX.Result, filename, ud.filename)

     hiding.vect <- which(colnames(temp.table) %in% c("FAM.ct", "FAM.tslope", "FAM.eb",
                                       "HEX.ct", "HEX.tslope", "HEX.eb",
                                       "IC.ct", "IC.tslope", "IC.eb",
                                       "RED647.ct", "RED647.tslope", "RED647.eb",
                                       "ROX.ct", "ROX.tslope", "ROX.eb",
                                       "filename", "replicate", "ud.filename"))
     datatable(
       temp.table,
       extensions = c('Buttons'),
       options = list(dom = 'Bfrtip', buttons = c('copy', 'csv', I('colvis')), pageLength = 10,
                      columnDefs = list(list(targets = hiding.vect,
                                             visible = FALSE)))
       )
     
} else{
     temp.table <-
          pq.s %>% ungroup() %>%
          filter(sample.type %in% pslv) %>%
          mutate(FAM.Result = ifelse(FAM.result == 1, "POS", "NEG"),
                 HEX.Result = ifelse(HEX.result == 1, "POS", "NEG"),
                 IC.Result = ifelse(IC.result == 1, "POS", "NEG"),
                 ROX.Result = ifelse(ROX.result == 1, "POS", "NEG")) %>%
          select(Sample.Name, Flag, FusionTestOrder, test.order, WellID, replicate,
                 FAM.ct:FAM.eb, FAM.Result, HEX.ct:HEX.eb, HEX.Result,
                 IC.ct:IC.eb, IC.Result,
                 ROX.ct:ROX.eb, ROX.Result, filename, ud.filename)

     hiding.vect <- which(colnames(temp.table) %in% c("FAM.ct", "FAM.tslope", "FAM.eb",
                                       "HEX.ct", "HEX.tslope", "HEX.eb",
                                       "IC.ct", "IC.tslope", "IC.eb",
                                       "ROX.ct", "ROX.tslope", "ROX.eb",
                                       "filename", "replicate", "ud.filename"))
     datatable(
       temp.table,
       extensions = c('Buttons'),
       options = list(dom = 'Bfrtip', buttons = c('copy', 'csv', I('colvis')), pageLength = 10,
                      columnDefs = list(list(targets = hiding.vect,
                                             visible = FALSE)))
     )
}
```
<a href="#top">Go to top</a>

# Negative Samples
*This table will comprise of all the samples categorized as a "ns" (Negative Sample) in the worklist.id. Its features are similar to that of the Positive Sample table.*
``` {R, result='asis', echo=FALSE, cache=FALSE, warning=FALSE, message=FALSE}
if(params$assay == "Paraflu"){
     temp.table.2 <- pq.s %>% ungroup() %>%
          filter(sample.type %in% nslv) %>%
          mutate(FAM.Result = ifelse(FAM.result == 1, "NEG", "POS"),
                 HEX.Result = ifelse(HEX.result == 1, "NEG", "POS"),
                 IC.Result = ifelse(IC.result == 1, "POS", "NEG"),
                 RED647.Result = ifelse(RED647.result == 1, "NEG", "POS"),
                 ROX.Result = ifelse(ROX.result == 1, "NEG", "POS")) %>%
          select(Sample.Name, Flag, FusionTestOrder, test.order, WellID, replicate,
                 FAM.ct:FAM.eb, FAM.Result, HEX.ct:HEX.eb, HEX.Result,
                 IC.ct:IC.eb, IC.Result, RED647.ct:RED647.eb, RED647.Result,
                 ROX.ct:ROX.eb, ROX.Result, filename, ud.filename)

     datatable(
       temp.table.2, 
       extensions = c('Buttons'),
       options = list(dom = 'Bfrtip', buttons = c('copy', 'csv', I('colvis')), pageLength = 10,
                      columnDefs = list(list(targets = hiding.vect,
                                             visible = FALSE)))
       )
} else{
     temp.table.2 <- pq.s %>% ungroup() %>%
          filter(sample.type %in% nslv) %>%
          mutate(FAM.Result = ifelse(FAM.result == 1, "NEG", "POS"),
                 HEX.Result = ifelse(HEX.result == 1, "NEG", "POS"),
                 IC.Result = ifelse(IC.result == 1, "POS", "NEG"),
                 ROX.Result = ifelse(ROX.result == 1, "NEG", "POS")) %>%
          select(Sample.Name, Flag, FusionTestOrder, test.order, WellID, replicate,
                 FAM.ct:FAM.eb, FAM.Result, HEX.ct:HEX.eb, HEX.Result,
                 IC.ct:IC.eb, IC.Result,
                 ROX.ct:ROX.eb, ROX.Result, filename, ud.filename)

     datatable(
       temp.table.2,
       extensions = c('Buttons'),
       options = list(dom = 'Bfrtip', buttons = c('copy', 'csv', I('colvis')), pageLength = 10,
                      columnDefs = list(list(targets = hiding.vect,
                                             visible = FALSE)))
     )
}

```

<!-- ```{asis, echo=TRUE, eval = (params$stats.filter != "none")} -->
<!-- # Filtered / Failed Samples -->
<!-- ``` -->

```{R, result='asis', warning=FALSE, echo=FALSE, cache=FALSE, eval = (stats.filter.lv.1 | stats.filter.lv.2)}

if(stats.filter.lv.1){
     filtered.table <- filtered.samples.1 %>% new_spreader()
     
     temp.table.3 <- filtered.table %>%
          ungroup %>%
          select(Sample.Name, Flag, FusionTestOrder, test.order, WellID, replicate,
                 FAM.ct:FAM.eb, HEX.ct:HEX.eb,
                 IC.ct:IC.eb, RED647.ct:RED647.eb,
                 ROX.ct:ROX.eb, filename)
     
          hiding.vect.3 <- which(colnames(temp.table.3) %in% c("FAM.ct", "FAM.tslope", "FAM.eb",
                                       "HEX.ct", "HEX.tslope", "HEX.eb",
                                       "IC.ct", "IC.tslope", "IC.eb",
                                       "RED647.ct", "RED647.tslope", "RED647.eb",
                                       "ROX.ct", "ROX.tslope", "ROX.eb",
                                       "filename", "replicate", "ud.filename"))
     
          datatable(
            temp.table.3,
            extensions = c('Buttons'),
            options = list(dom = 'Bfrtip', buttons = c('copy', 'csv', I('colvis')), pageLength = 10,
                           columnDefs = list(list(targets = hiding.vect.3,
                                                  visible = FALSE)))
          )
}

if(stats.filter.lv.2){
     failed.table <- filter.2 %>% select(-pass, -threshold, -direction) %>% spreader()
     
     temp.table.4 <- failed.table %>%
          ungroup %>%
          select(Sample.Name, Flag, FusionTestOrder, test.order, WellID, replicate,
                 FAM.ct:FAM.eb, FAM.result, HEX.ct:HEX.eb, HEX.result,
                 IC.ct:IC.eb, IC.result, RED647.ct:RED647.eb, RED647.result,
                 ROX.ct:ROX.eb, ROX.result, filename)
     
          hiding.vect.4 <- which(colnames(temp.table.4) %in% c("FAM.ct", "FAM.tslope", "FAM.eb",
                                       "HEX.ct", "HEX.tslope", "HEX.eb",
                                       "IC.ct", "IC.tslope", "IC.eb",
                                       "RED647.ct", "RED647.tslope", "RED647.eb",
                                       "ROX.ct", "ROX.tslope", "ROX.eb",
                                       "filename", "replicate", "ud.filename"))
     
          datatable(
            temp.table.4,
            extensions = c('Buttons'),
            options = list(dom = 'Bfrtip', buttons = c('copy', 'csv', I('colvis')), pageLength = 10,
                           columnDefs = list(list(targets = hiding.vect.4,
                                                  visible = FALSE)))
          )
}
```

<!-- #Summary Plots {.tabset .tabset-pills} -->
<!-- *Pro Tip: If you right-click the graph and open in a new tab/window the size should be enlarged. Alternatively if you right-click and hit save this work as well.* -->

<!-- ```{R, result='asis', warning=FALSE, echo=FALSE, cache=FALSE} -->

<!-- ct.limits <- pq %>% -->
<!--      group_by(Channel, sample.type) %>% -->
<!--      summarise(mCt=mean(ct, na.rm=TRUE), sdCt = sd(ct, na.rm=TRUE)) %>% -->
<!--      mutate(UCL = mCt + 3*sdCt, MUCL = mCt +2*sdCt, MLCL = mCt - 2*sdCt, LCL = mCt - 3*sdCt) -->
<!-- eb.limits <- pq %>% -->
<!--      group_by(Channel, sample.type) %>% -->
<!--      summarise(mEB=mean(EstimatedBaseline, na.rm=TRUE), sdEB = sd(EstimatedBaseline, na.rm=TRUE)) %>% -->
<!--      mutate(UCL = mEB + 3*sdEB, MUCL = mEB +2*sdEB, MLCL = mEB - 2*sdEB, LCL = mEB - 3*sdEB) -->

<!-- pq$Channel = factor(pq$Channel, levels=c("FAM", "HEX", "ROX", "RED647", "IC")) -->

<!-- if(params$graphing == "fvf"){ -->

<!--      p1 <- pq %>% -->
<!--           ggplot(aes(x=filename, y=RFU.Range)) + geom_boxplot(outlier.shape = NA) + geom_jitter(width=0.25, aes(color=filename)) +  -->
<!--           facet_grid(Channel~sample.type, scales = "free") + -->
<!--           geom_hline(data=assay.limits, aes(yintercept=threshold), color="red") + -->
<!--           theme(legend.position="right", legend.direction="vertical", axis.text.x=element_blank(), axis.title.x=element_blank()) + -->
<!--           ggtitle("RFU Ranges faceted by Channel and Sample Type across the File(s)") -->

<!--      p2 <- pq %>% -->
<!--           ggplot(aes(x=filename, y=ct)) + geom_boxplot(outlier.shape = NA) + geom_jitter(width=0.25, aes(color=filename)) + -->
<!--           facet_grid(Channel~sample.type, scales = "free") + -->
<!--           geom_hline(data=ct.limits, aes(yintercept=UCL), color="red") + -->
<!--           geom_hline(data=ct.limits, aes(yintercept=LCL), color="red") + -->
<!--           geom_hline(data=ct.limits, aes(yintercept=MUCL), color="orange", linetype="dashed") + -->
<!--           geom_hline(data=ct.limits, aes(yintercept=MLCL), color="orange", linetype="dashed") + -->
<!--           geom_hline(data=ct.limits, aes(yintercept=mCt), color="green", size = 1) + -->
<!--           theme(legend.position="right", legend.direction="vertical", axis.text.x=element_blank(), axis.title.x=element_blank()) + -->
<!--           ggtitle("Cts faceted by Channel and Sample Type across the File(s)") -->

<!--      p3 <- pq %>% -->
<!--           ggplot(aes(x=filename, y=EstimatedBaseline)) + -->
<!--           geom_boxplot(outlier.shape = NA) + -->
<!--           geom_jitter(width=0.25, aes(color=filename)) + -->
<!--           facet_grid(Channel~sample.type, scales = "free") + -->
<!--           geom_hline(data=eb.limits, aes(yintercept=UCL), color="red") + -->
<!--           geom_hline(data=eb.limits, aes(yintercept=LCL), color="red") + -->
<!--           geom_hline(data=eb.limits, aes(yintercept=MUCL), color="orange", linetype="dashed") + -->
<!--           geom_hline(data=eb.limits, aes(yintercept=MLCL), color="orange", linetype="dashed") + -->
<!--           geom_hline(data=eb.limits, aes(yintercept=mEB), color="green", size = 1) + -->
<!--           theme(legend.position="right", legend.direction="vertical", axis.text.x=element_blank(), axis.title.x=element_blank()) + -->
<!--           ggtitle("Estimated Baselines faceted by Channel and Sample Type across the File(s)") -->

<!--      render.graphics <- TRUE -->

<!-- } else if(params$graphing == "time"){ -->
<!--      pq$completion.date <- as.Date(pq$completion.date) -->
<!--      pq$completion.date <- as.factor(pq$completion.date) -->

<!--      p1 <- pq %>% -->
<!--           ggplot(aes(x=completion.date, y=RFU.Range)) + -->
<!--           geom_boxplot(outlier.shape = NA) + geom_jitter(width=0.25, aes(color=completion.date)) +  -->
<!--           facet_grid(Channel~sample.type, scales = "free") + -->
<!--           geom_hline(data=assay.limits, aes(yintercept=threshold), color="red") + -->
<!--           theme(legend.position="right", legend.direction="vertical", axis.text.x=element_blank(), axis.title.x=element_blank()) + -->
<!--           ggtitle("RFU Ranges faceted by Channel and Sample Type across Time") -->

<!--      p2 <- pq %>% -->
<!--           ggplot(aes(x=completion.date, y=ct)) + -->
<!--           geom_boxplot(outlier.shape = NA) + geom_jitter(width=0.25, aes(color=completion.date)) + -->
<!--           facet_grid(Channel~sample.type, scales = "free") + -->
<!--           geom_hline(data=ct.limits, aes(yintercept=UCL), color="red") + -->
<!--           geom_hline(data=ct.limits, aes(yintercept=LCL), color="red") + -->
<!--           geom_hline(data=ct.limits, aes(yintercept=MUCL), color="orange", linetype="dashed") + -->
<!--           geom_hline(data=ct.limits, aes(yintercept=MLCL), color="orange", linetype="dashed") + -->
<!--           geom_hline(data=ct.limits, aes(yintercept=mCt), color="green", size = 1) + -->
<!--           theme(legend.position="right", legend.direction="vertical", axis.text.x=element_blank(), axis.title.x=element_blank()) + -->
<!--           ggtitle("Cts faceted by Channel and Sample Type across Time") -->

<!--      p3 <- pq %>% -->
<!--           ggplot(aes(x=completion.date, y=EstimatedBaseline)) + -->
<!--           geom_boxplot(outlier.shape = NA) + -->
<!--           geom_jitter(width=0.25, aes(color=completion.date)) + -->
<!--           facet_grid(Channel~sample.type, scales = "free") + -->
<!--           geom_hline(data=eb.limits, aes(yintercept=UCL), color="red") + -->
<!--           geom_hline(data=eb.limits, aes(yintercept=LCL), color="red") + -->
<!--           geom_hline(data=eb.limits, aes(yintercept=MUCL), color="orange", linetype="dashed") + -->
<!--           geom_hline(data=eb.limits, aes(yintercept=MLCL), color="orange", linetype="dashed") + -->
<!--           geom_hline(data=eb.limits, aes(yintercept=mEB), color="green", size = 1) + -->
<!--           theme(legend.position="right", legend.direction="vertical", axis.text.x=element_blank(), axis.title.x=element_blank()) + -->
<!--           ggtitle("Estimated Baselines faceted by Channel and Sample Type across Time") -->

<!--      render.graphics <- TRUE -->
<!-- } else if(params$graphing == "instrument"){ -->
<!--      p1 <- pq %>% -->
<!--           ggplot(aes(x=pantherSN, y=RFU.Range)) + geom_boxplot(outlier.shape = NA) + geom_jitter(width=0.25, aes(color=pantherSN)) +  -->
<!--           facet_grid(Channel~sample.type, scales = "free") + -->
<!--           geom_hline(data=assay.limits, aes(yintercept=threshold), color="red") + -->
<!--           theme(legend.position="right", legend.direction="vertical", axis.text.x=element_blank(), axis.title.x=element_blank()) + -->
<!--           ggtitle("RFU Ranges faceted by Channel and Sample Type across different instruments") -->

<!--      p2 <- pq %>% -->
<!--           ggplot(aes(x=pantherSN, y=ct)) + geom_boxplot(outlier.shape = NA) + geom_jitter(width=0.25, aes(color=pantherSN)) + -->
<!--           facet_grid(Channel~sample.type, scales = "free") + -->
<!--           geom_hline(data=ct.limits, aes(yintercept=UCL), color="red") + -->
<!--           geom_hline(data=ct.limits, aes(yintercept=LCL), color="red") + -->
<!--           geom_hline(data=ct.limits, aes(yintercept=MUCL), color="orange", linetype="dashed") + -->
<!--           geom_hline(data=ct.limits, aes(yintercept=MLCL), color="orange", linetype="dashed") + -->
<!--           geom_hline(data=ct.limits, aes(yintercept=mCt), color="green", size = 1) + -->
<!--           theme(legend.position="right", legend.direction="vertical", axis.text.x=element_blank(), axis.title.x=element_blank()) + -->
<!--           ggtitle("Cts faceted by Channel and Sample Type across different instruments") -->

<!--      p3 <- pq %>% -->
<!--           ggplot(aes(x=pantherSN, y=EstimatedBaseline)) + -->
<!--           geom_boxplot(outlier.shape = NA) + -->
<!--           geom_jitter(width=0.25, aes(color=pantherSN)) + -->
<!--           facet_grid(Channel~sample.type, scales = "free") + -->
<!--           geom_hline(data=eb.limits, aes(yintercept=UCL), color="red") + -->
<!--           geom_hline(data=eb.limits, aes(yintercept=LCL), color="red") + -->
<!--           geom_hline(data=eb.limits, aes(yintercept=MUCL), color="orange", linetype="dashed") + -->
<!--           geom_hline(data=eb.limits, aes(yintercept=MLCL), color="orange", linetype="dashed") + -->
<!--           geom_hline(data=eb.limits, aes(yintercept=mEB), color="green", size = 1) + -->
<!--           theme(legend.position="right", legend.direction="vertical", axis.text.x=element_blank(), axis.title.x=element_blank()) + -->
<!--           ggtitle("Estimated Baselines faceted by Channel and Sample Type across different instruments") -->

<!--      render.graphics <- TRUE -->
<!-- } else{ -->
<!--      render.graphics <- FALSE -->
<!--      print("Graphics have been surpressed") -->
<!-- } -->
<!-- save.image(rdata.filename) -->
<!-- ``` -->

<!-- ##RFU Range -->
<!-- *The red line represents the cutoffs under Assay Defined Thresholds* -->
<!-- ```{R, echo=FALSE, warning=FALSE, cache=FALSE, eval=render.graphics, fig.height=8, fig.width=12, dpi=300} -->
<!-- if(render.graphics) -->
<!--      print(p1 + theme(legend.text = element_text(size=8))) -->
<!-- ``` -->

<!-- ##Ct Non-Normalized -->
<!-- <ul> -->
<!-- <li><b>Green line</b> - represents the mean of each Channel and Sample Type.</li> -->
<!-- <li><b>Orange, dashed line</b> - represents two standard deviations from the mean.</li> -->
<!-- <li><b>Red line</b> - represents three standard deviations from the mean.</li> -->
<!-- </ul> -->
<!-- ```{R, echo=FALSE, warning=FALSE, cache=FALSE, eval=render.graphics, fig.height=8, fig.width=12, dpi=300} -->
<!-- if(render.graphics) -->
<!--      print(p2 + theme(legend.text = element_text(size=8))) -->
<!-- ``` -->

<!-- ##Estimated Baseline -->
<!-- <ul> -->
<!-- <li><b>Green line</b> - represents the mean of each Channel and Sample Type.</li> -->
<!-- <li><b>Orange, dashed line</b> - represents three standard deviations from the mean.</li> -->
<!-- <li><b>Red line</b> - represents four standard deviations from the mean.</li> -->
<!-- </ul> -->
<!-- ```{R, echo=FALSE, warning=FALSE, cache=FALSE, eval=render.graphics, fig.height=8, fig.width=12, dpi=300} -->
<!-- if(render.graphics) -->
<!--      print(p3 + theme(legend.text = element_text(size=8))) -->
<!-- ``` -->

<!-- <a href="#top">Go to top</a> -->
